// Package config provides vulnerability scanning configuration management.
package config

import (
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"gopkg.in/yaml.v3"
)

// VulnerabilityConfig holds vulnerability scanning configuration parameters.
// This structure centralizes vulnerability scanning settings, making them easier to
// manage, test, and extend for security scanning operations.
type VulnerabilityConfig struct {
	// FailOnSeverity specifies which vulnerability severity levels cause build failure
	// Valid values: CRITICAL, HIGH, MEDIUM, LOW
	FailOnSeverity []string `yaml:"fail_on_severity"`

	// TimeoutSeconds defines the maximum time allowed for vulnerability scanning
	TimeoutSeconds int `yaml:"timeout_seconds"`

	// ScanLevel specifies the granularity of the vulnerability scan
	// Valid values: module, package, symbol
	ScanLevel string `yaml:"scan_level"`

	// OutputFormat specifies the output format for vulnerability reports
	// Valid values: json, text
	OutputFormat string `yaml:"output_format"`

	// RetryAttempts defines how many times to retry on network failures
	RetryAttempts int `yaml:"retry_attempts"`

	// Reporting contains reporting-specific configuration
	Reporting ReportingConfig `yaml:"reporting"`
}

// ReportingConfig holds configuration for vulnerability report generation
type ReportingConfig struct {
	// IncludeDetails controls whether vulnerability details are included in output
	IncludeDetails bool `yaml:"include_details"`

	// IncludeRemediation controls whether remediation guidance is included
	IncludeRemediation bool `yaml:"include_remediation"`

	// GenerateCorrelationID controls whether correlation IDs are generated for traceability
	GenerateCorrelationID bool `yaml:"generate_correlation_id"`
}

// Default constants for vulnerability configuration
const (
	// DefaultConfigFileName is the default name for vulnerability configuration file
	DefaultConfigFileName = ".govulncheck.yaml"

	// DefaultTimeoutSeconds is the default timeout for vulnerability scans
	DefaultTimeoutSeconds = 300

	// DefaultRetryAttempts is the default number of retry attempts
	DefaultRetryAttempts = 2

	// DefaultScanLevel is the default scan granularity
	DefaultScanLevel = "symbol"

	// DefaultOutputFormat is the default output format
	DefaultOutputFormat = "json"
)

// Valid values for configuration fields
var (
	// ValidSeverityLevels are the allowed severity levels
	ValidSeverityLevels = []string{"CRITICAL", "HIGH", "MEDIUM", "LOW"}

	// ValidScanLevels are the allowed scan granularity levels
	ValidScanLevels = []string{"module", "package", "symbol"}

	// ValidOutputFormats are the allowed output formats
	ValidOutputFormats = []string{"json", "text"}
)

// NewDefaultVulnerabilityConfig creates a new VulnerabilityConfig with default values.
// This provides a secure starting point for vulnerability scanning configuration.
func NewDefaultVulnerabilityConfig() *VulnerabilityConfig {
	return &VulnerabilityConfig{
		FailOnSeverity: []string{"HIGH", "CRITICAL"},
		TimeoutSeconds: DefaultTimeoutSeconds,
		ScanLevel:      DefaultScanLevel,
		OutputFormat:   DefaultOutputFormat,
		RetryAttempts:  DefaultRetryAttempts,
		Reporting: ReportingConfig{
			IncludeDetails:        true,
			IncludeRemediation:    true,
			GenerateCorrelationID: true,
		},
	}
}

// LoadVulnerabilityConfig loads vulnerability configuration from a YAML file.
// If the file doesn't exist, returns default configuration.
// Returns an error if the file exists but cannot be parsed or contains invalid values.
func LoadVulnerabilityConfig(configPath string) (*VulnerabilityConfig, error) {
	// If no path provided, look for default config file
	if configPath == "" {
		configPath = DefaultConfigFileName
	}

	// Validate config path for security (prevent path traversal)
	if err := validateConfigPath(configPath); err != nil {
		return nil, fmt.Errorf("invalid config path %s: %w", configPath, err)
	}

	// Check if config file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		// Return default configuration if file doesn't exist
		return NewDefaultVulnerabilityConfig(), nil
	}

	// Read the configuration file
	data, err := os.ReadFile(configPath) // #nosec G304 - path validated above
	if err != nil {
		return nil, fmt.Errorf("failed to read vulnerability config file %s: %w", configPath, err)
	}

	// Parse YAML configuration
	config := NewDefaultVulnerabilityConfig()
	if err := yaml.Unmarshal(data, config); err != nil {
		return nil, fmt.Errorf("failed to parse vulnerability config file %s: %w", configPath, err)
	}

	// Validate the configuration
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("invalid vulnerability configuration in %s: %w", configPath, err)
	}

	return config, nil
}

// LoadVulnerabilityConfigFromProjectRoot loads vulnerability configuration from project root.
// Searches for .govulncheck.yaml in the current directory and parent directories.
func LoadVulnerabilityConfigFromProjectRoot() (*VulnerabilityConfig, error) {
	// Start from current directory and search upwards
	currentDir, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("failed to get current directory: %w", err)
	}

	// Search for config file in current and parent directories
	for {
		configPath := filepath.Join(currentDir, DefaultConfigFileName)
		if _, err := os.Stat(configPath); err == nil {
			return LoadVulnerabilityConfig(configPath)
		}

		// Move to parent directory
		parentDir := filepath.Dir(currentDir)
		if parentDir == currentDir {
			// Reached filesystem root, use default config
			break
		}
		currentDir = parentDir
	}

	// No config file found, return default configuration
	return NewDefaultVulnerabilityConfig(), nil
}

// Validate checks if the vulnerability configuration contains valid values.
// Returns an error describing any validation failures.
func (vc *VulnerabilityConfig) Validate() error {
	var errors []string

	// Validate FailOnSeverity
	if len(vc.FailOnSeverity) == 0 {
		errors = append(errors, "fail_on_severity cannot be empty")
	} else {
		for _, severity := range vc.FailOnSeverity {
			if !slices.Contains(ValidSeverityLevels, severity) {
				errors = append(errors, fmt.Sprintf("invalid severity level '%s', must be one of: %s", severity, strings.Join(ValidSeverityLevels, ", ")))
			}
		}
	}

	// Validate TimeoutSeconds
	if vc.TimeoutSeconds <= 0 {
		errors = append(errors, "timeout_seconds must be greater than 0")
	}
	if vc.TimeoutSeconds > 3600 {
		errors = append(errors, "timeout_seconds must not exceed 3600 seconds (1 hour)")
	}

	// Validate ScanLevel
	if !slices.Contains(ValidScanLevels, vc.ScanLevel) {
		errors = append(errors, fmt.Sprintf("invalid scan_level '%s', must be one of: %s", vc.ScanLevel, strings.Join(ValidScanLevels, ", ")))
	}

	// Validate OutputFormat
	if !slices.Contains(ValidOutputFormats, vc.OutputFormat) {
		errors = append(errors, fmt.Sprintf("invalid output_format '%s', must be one of: %s", vc.OutputFormat, strings.Join(ValidOutputFormats, ", ")))
	}

	// Validate RetryAttempts
	if vc.RetryAttempts < 0 {
		errors = append(errors, "retry_attempts cannot be negative")
	}
	if vc.RetryAttempts > 10 {
		errors = append(errors, "retry_attempts should not exceed 10")
	}

	if len(errors) > 0 {
		return fmt.Errorf("validation errors: %s", strings.Join(errors, "; "))
	}

	return nil
}

// ShouldFailOnSeverity checks if the given severity level should cause build failure.
func (vc *VulnerabilityConfig) ShouldFailOnSeverity(severity string) bool {
	return slices.Contains(vc.FailOnSeverity, strings.ToUpper(severity))
}

// IsHighSeverityBlocking returns true if HIGH or CRITICAL vulnerabilities cause build failure.
func (vc *VulnerabilityConfig) IsHighSeverityBlocking() bool {
	return vc.ShouldFailOnSeverity("HIGH") || vc.ShouldFailOnSeverity("CRITICAL")
}

// GetEffectiveTimeout returns the timeout in seconds, ensuring it's within reasonable bounds.
func (vc *VulnerabilityConfig) GetEffectiveTimeout() int {
	if vc.TimeoutSeconds <= 0 {
		return DefaultTimeoutSeconds
	}
	if vc.TimeoutSeconds > 3600 {
		return 3600 // Cap at 1 hour
	}
	return vc.TimeoutSeconds
}

// String returns a human-readable representation of the vulnerability configuration.
func (vc *VulnerabilityConfig) String() string {
	return fmt.Sprintf("VulnerabilityConfig{FailOnSeverity: %v, TimeoutSeconds: %d, ScanLevel: %s, OutputFormat: %s, RetryAttempts: %d}",
		vc.FailOnSeverity, vc.TimeoutSeconds, vc.ScanLevel, vc.OutputFormat, vc.RetryAttempts)
}

// validateConfigPath validates that the configuration file path is safe to read.
// This prevents path traversal attacks and ensures we only read legitimate config files.
func validateConfigPath(configPath string) error {
	// Clean the path to resolve any . or .. elements
	cleanPath := filepath.Clean(configPath)

	// Ensure it's a YAML file
	if !strings.HasSuffix(cleanPath, ".yaml") && !strings.HasSuffix(cleanPath, ".yml") {
		return fmt.Errorf("configuration file must have .yaml or .yml extension")
	}

	// Check for path traversal attempts after cleaning
	if strings.Contains(cleanPath, "..") {
		return fmt.Errorf("path traversal not allowed")
	}

	// For relative paths, ensure they don't try to escape current directory tree
	if !filepath.IsAbs(cleanPath) {
		// Check if the original path (before cleaning) tries to escape
		if strings.HasPrefix(configPath, "../") || strings.HasPrefix(configPath, "..\\") {
			return fmt.Errorf("relative paths cannot escape current directory")
		}
	}

	return nil
}
