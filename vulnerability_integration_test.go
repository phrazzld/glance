package main

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// VulnerabilityScanResult represents the result of a vulnerability scan
type VulnerabilityScanResult struct {
	ExitCode      int           `json:"exit_code"`
	Duration      time.Duration `json:"duration"`
	StdOut        string        `json:"stdout"`
	StdErr        string        `json:"stderr"`
	VulnCount     int           `json:"vulnerability_count"`
	HasVulns      bool          `json:"has_vulnerabilities"`
	ProjectPath   string        `json:"project_path"`
	ScanSucceeded bool          `json:"scan_succeeded"`
}

// TestVulnerabilityDetectionIntegration tests the core vulnerability detection capability
func TestVulnerabilityDetectionIntegration(t *testing.T) {
	// Skip if govulncheck not available
	if _, err := exec.LookPath("govulncheck"); err != nil {
		t.Skip("govulncheck not available, skipping integration tests")
	}

	testCases := []struct {
		name            string
		projectPath     string
		expectVulns     bool
		expectSuccess   bool
		maxDuration     time.Duration
		expectedStrings []string
	}{
		{
			name:            "Clean project scan",
			projectPath:     "testdata/clean-project",
			expectVulns:     false,
			expectSuccess:   true,
			maxDuration:     30 * time.Second,
			expectedStrings: []string{"=== Symbol Results ==="},
		},
		{
			name:            "Vulnerable project scan",
			projectPath:     "testdata/vulnerable-project",
			expectVulns:     true,
			expectSuccess:   false, // govulncheck returns non-zero when vulns found
			maxDuration:     30 * time.Second,
			expectedStrings: []string{"=== Symbol Results ===", "vulnerability", "Your code is affected"},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := runVulnerabilityScan(t, tc.projectPath, tc.maxDuration)

			// Verify scan completed within time limit
			assert.LessOrEqual(t, result.Duration, tc.maxDuration,
				"Scan should complete within %v", tc.maxDuration)

			// Verify scan success/failure as expected
			if tc.expectSuccess {
				// Clean projects may still find standard library vulnerabilities, accept exit code 0 or 3
				assert.True(t, result.ExitCode == 0 || result.ExitCode == 3,
					"Clean project scan should succeed (0) or find standard lib vulns (3), got %d", result.ExitCode)
			} else {
				// Vulnerable projects should find vulnerabilities
				assert.NotEqual(t, 0, result.ExitCode,
					"Vulnerable project scan should detect vulnerabilities")
			}

			// Verify expected content in output
			combinedOutput := result.StdOut + result.StdErr
			for _, expectedStr := range tc.expectedStrings {
				assert.Contains(t, combinedOutput, expectedStr,
					"Output should contain '%s'", expectedStr)
			}

			// Verify vulnerability detection logic
			result.HasVulns = strings.Contains(combinedOutput, "vulnerability") ||
				strings.Contains(combinedOutput, "Your code is affected")
			if tc.expectVulns {
				assert.True(t, result.HasVulns, "Should detect vulnerabilities in vulnerable project")
			}

			t.Logf("Scan completed in %v with exit code %d", result.Duration, result.ExitCode)
		})
	}
}

// TestConfigurationFileSupport tests that .govulncheck.yaml files are properly recognized
func TestConfigurationFileSupport(t *testing.T) {
	testCases := []struct {
		name        string
		projectPath string
	}{
		{
			name:        "Clean project config",
			projectPath: "testdata/clean-project",
		},
		{
			name:        "Vulnerable project config",
			projectPath: "testdata/vulnerable-project",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			configPath := filepath.Join(tc.projectPath, ".govulncheck.yaml")

			// Verify config file exists
			assert.FileExists(t, configPath, "Config file should exist")

			// Verify config file is readable and contains expected structure
			configData, err := os.ReadFile(configPath)
			require.NoError(t, err, "Should be able to read config file")

			configStr := string(configData)
			assert.Contains(t, configStr, "fail_on_severity", "Config should contain severity settings")
			assert.Contains(t, configStr, "HIGH", "Config should specify HIGH severity")
			assert.Contains(t, configStr, "CRITICAL", "Config should specify CRITICAL severity")
		})
	}
}

// TestScanPerformanceAndReliability tests that scans complete within acceptable time bounds
func TestScanPerformanceAndReliability(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping performance tests in short mode")
	}

	// Skip if govulncheck not available
	if _, err := exec.LookPath("govulncheck"); err != nil {
		t.Skip("govulncheck not available, skipping performance tests")
	}

	const maxScanDuration = 60 * time.Second // From requirements
	const iterations = 3

	projectPath := "testdata/clean-project"
	var durations []time.Duration

	for i := 0; i < iterations; i++ {
		t.Run(fmt.Sprintf("Iteration_%d", i+1), func(t *testing.T) {
			result := runVulnerabilityScan(t, projectPath, maxScanDuration)

			assert.LessOrEqual(t, result.Duration, maxScanDuration,
				"Scan iteration %d should complete within %v", i+1, maxScanDuration)

			durations = append(durations, result.Duration)
			t.Logf("Iteration %d completed in %v", i+1, result.Duration)
		})
	}

	// Calculate average duration
	var totalDuration time.Duration
	for _, d := range durations {
		totalDuration += d
	}
	avgDuration := totalDuration / time.Duration(len(durations))

	t.Logf("Average scan duration: %v (target: <%v)", avgDuration, maxScanDuration)
	assert.Less(t, avgDuration, maxScanDuration,
		"Average scan duration should be well under target")
}

// TestScanOutputFormats tests different output format options
func TestScanOutputFormats(t *testing.T) {
	if _, err := exec.LookPath("govulncheck"); err != nil {
		t.Skip("govulncheck not available, skipping format tests")
	}

	testCases := []struct {
		name           string
		format         string
		expectedOutput []string
	}{
		{
			name:           "Text format (default)",
			format:         "",
			expectedOutput: []string{"=== Symbol Results ==="},
		},
		{
			name:           "JSON format",
			format:         "json",
			expectedOutput: []string{`"type"`, `"config"`},
		},
	}

	projectPath := "testdata/clean-project"

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := runVulnerabilityScanWithFormat(t, projectPath, tc.format, 30*time.Second)

			for _, expected := range tc.expectedOutput {
				assert.Contains(t, result.StdOut, expected,
					"Output should contain expected format elements")
			}

			if tc.format == "json" {
				// Verify JSON output contains expected JSON elements (govulncheck outputs multiple JSON objects)
				assert.Contains(t, result.StdOut, `"type"`, "JSON output should contain type field")
				assert.True(t, strings.Contains(result.StdOut, "{") && strings.Contains(result.StdOut, "}"),
					"JSON output should contain JSON object markers")
			}
		})
	}
}

// TestIsolationAndConcurrency tests that multiple scans can run without interference
func TestIsolationAndConcurrency(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping concurrency tests in short mode")
	}

	if _, err := exec.LookPath("govulncheck"); err != nil {
		t.Skip("govulncheck not available, skipping concurrency tests")
	}

	const numConcurrentScans = 3
	results := make(chan VulnerabilityScanResult, numConcurrentScans)

	// Launch concurrent scans
	for i := 0; i < numConcurrentScans; i++ {
		go func(scanID int) {
			projectPath := "testdata/clean-project"
			result := runVulnerabilityScan(t, projectPath, 30*time.Second)
			result.ProjectPath = fmt.Sprintf("scan_%d", scanID)
			results <- result
		}(i)
	}

	// Collect results
	var scanResults []VulnerabilityScanResult
	for i := 0; i < numConcurrentScans; i++ {
		result := <-results
		scanResults = append(scanResults, result)
	}

	// Verify all scans completed successfully
	for i, result := range scanResults {
		assert.True(t, result.ExitCode == 0 || result.ExitCode == 3,
			"Concurrent scan %d should complete successfully", i)
		assert.Less(t, result.Duration, 30*time.Second,
			"Concurrent scan %d should complete within time limit", i)
	}

	t.Logf("All %d concurrent scans completed successfully", numConcurrentScans)
}

// Helper function to run vulnerability scan with default text format
func runVulnerabilityScan(t *testing.T, projectPath string, timeout time.Duration) VulnerabilityScanResult {
	return runVulnerabilityScanWithFormat(t, projectPath, "", timeout)
}

// Helper function to run vulnerability scan with specified format
func runVulnerabilityScanWithFormat(t *testing.T, projectPath string, format string, timeout time.Duration) VulnerabilityScanResult {
	// Verify project path exists
	absPath, err := filepath.Abs(projectPath)
	require.NoError(t, err, "Should be able to get absolute path")
	require.DirExists(t, absPath, "Project directory should exist")

	// Change to project directory
	originalDir, err := os.Getwd()
	require.NoError(t, err, "Should be able to get current directory")
	defer func() {
		os.Chdir(originalDir)
	}()

	err = os.Chdir(absPath)
	require.NoError(t, err, "Should be able to change to project directory")

	// Prepare command
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	args := []string{"./..."}
	if format != "" {
		args = append([]string{"-format", format}, args...)
	}

	start := time.Now()
	cmd := exec.CommandContext(ctx, "govulncheck", args...)

	output, err := cmd.CombinedOutput()
	duration := time.Since(start)

	result := VulnerabilityScanResult{
		Duration:      duration,
		StdOut:        string(output),
		ProjectPath:   projectPath,
		ScanSucceeded: true,
	}

	if err != nil {
		if exitError, ok := err.(*exec.ExitError); ok {
			result.ExitCode = exitError.ExitCode()
		} else {
			result.ExitCode = -1
			result.StdErr = err.Error()
			result.ScanSucceeded = false
		}
	}

	return result
}
