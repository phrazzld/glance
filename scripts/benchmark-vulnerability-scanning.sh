#!/bin/bash

# benchmark-vulnerability-scanning.sh
# Performance benchmarking tool for vulnerability scanning optimizations
#
# This script measures and compares the performance of different vulnerability scanning approaches:
# 1. Original govulncheck direct execution
# 2. Current CI workflow approach
# 3. Optimized caching approach
#
# Usage: ./benchmark-vulnerability-scanning.sh [iterations] [output-file]

set -euo pipefail

# Configuration
ITERATIONS="${1:-5}"
OUTPUT_FILE="${2:-vulnerability-scan-benchmark.json}"
SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Ensure we're in the project root
cd "$PROJECT_ROOT"

# Check prerequisites
check_prerequisites() {
    local missing_tools=()

    if ! command -v govulncheck >/dev/null 2>&1; then
        missing_tools+=("govulncheck")
    fi

    if ! command -v jq >/dev/null 2>&1; then
        missing_tools+=("jq")
    fi

    if ! command -v yq >/dev/null 2>&1; then
        echo "Warning: yq not found, some tests may be skipped"
    fi

    if [ ${#missing_tools[@]} -gt 0 ]; then
        echo "Error: Missing required tools: ${missing_tools[*]}"
        echo "Install with:"
        for tool in "${missing_tools[@]}"; do
            case $tool in
                govulncheck)
                    echo "  go install golang.org/x/vuln/cmd/govulncheck@latest"
                    ;;
                jq)
                    echo "  sudo apt install jq  # or brew install jq"
                    ;;
            esac
        done
        exit 1
    fi
}

# Initialize benchmark results
init_benchmark() {
    local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
    local git_commit=$(git rev-parse --short HEAD)
    local git_branch=$(git rev-parse --abbrev-ref HEAD)

    cat > "$OUTPUT_FILE" <<EOF
{
  "benchmark_metadata": {
    "timestamp": "$timestamp",
    "git_commit": "$git_commit",
    "git_branch": "$git_branch",
    "iterations": $ITERATIONS,
    "project_root": "$PROJECT_ROOT",
    "govulncheck_version": "$(govulncheck -version 2>&1 | head -1 || echo 'unknown')",
    "go_version": "$(go version)"
  },
  "test_scenarios": [],
  "summary": {}
}
EOF
}

# Logging function with structured output
log_benchmark() {
    local level="$1"
    local message="$2"
    local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')

    echo "{\"timestamp\": \"$timestamp\", \"level\": \"$level\", \"message\": \"$message\"}" >&2
}

# Measure execution time and capture results
measure_execution() {
    local test_name="$1"
    local command="$2"
    local iteration="$3"

    log_benchmark "INFO" "Running $test_name (iteration $iteration)"

    local start_time=$(date +%s)
    local start_ns=$(date +%N 2>/dev/null || echo "000000000")
    local exit_code=0
    local output=""
    local error_output=""

    # Execute command and capture output
    if output=$(eval "$command" 2>&1); then
        exit_code=0
    else
        exit_code=$?
    fi

    local end_time=$(date +%s)
    local end_ns=$(date +%N 2>/dev/null || echo "000000000")

    # Calculate duration in milliseconds
    local duration_s=$((end_time - start_time))
    local duration_ns=$((end_ns - start_ns))
    local duration_ms=$((duration_s * 1000 + duration_ns / 1000000))

    # Parse vulnerability count if JSON output
    local vuln_count=0
    if echo "$output" | jq . >/dev/null 2>&1; then
        vuln_count=$(echo "$output" | grep -c '"osv"' 2>/dev/null || echo "0")
    fi

    # Create test result
    local result="{
        \"test_name\": \"$test_name\",
        \"iteration\": $iteration,
        \"duration_ms\": $duration_ms,
        \"exit_code\": $exit_code,
        \"vulnerability_count\": $vuln_count,
        \"timestamp\": \"$(date -u '+%Y-%m-%dT%H:%M:%SZ')\",
        \"command\": \"$command\"
    }"

    # Add to results file
    local temp_file=$(mktemp)
    jq ".test_scenarios += [$result]" "$OUTPUT_FILE" > "$temp_file"
    mv "$temp_file" "$OUTPUT_FILE"

    log_benchmark "INFO" "$test_name (iteration $iteration) completed in ${duration_ms}ms"
}

# Test 1: Direct govulncheck execution
test_direct_govulncheck() {
    log_benchmark "INFO" "Starting direct govulncheck benchmark"

    for i in $(seq 1 "$ITERATIONS"); do
        measure_execution "direct_govulncheck" "govulncheck ./..." "$i"
    done
}

# Test 2: JSON output with timeout (simulating CI approach)
test_ci_style_govulncheck() {
    log_benchmark "INFO" "Starting CI-style govulncheck benchmark"

    local timeout=300
    if [ -f ".govulncheck.yaml" ] && command -v yq >/dev/null 2>&1; then
        timeout=$(yq eval '.timeout_seconds // 300' .govulncheck.yaml)
    fi

    for i in $(seq 1 "$ITERATIONS"); do
        measure_execution "ci_style_govulncheck" "timeout ${timeout}s govulncheck -format json ./..." "$i"
    done
}

# Test 3: Optimized approach with caching simulation
test_optimized_govulncheck() {
    log_benchmark "INFO" "Starting optimized govulncheck benchmark with caching simulation"

    local cache_file="/tmp/vuln-scan-cache-test.json"
    local metadata_file="/tmp/vuln-scan-metadata-test.json"

    for i in $(seq 1 "$ITERATIONS"); do
        local use_cache="false"

        # Simulate cache hit logic
        if [ -f "$cache_file" ] && [ -f "$metadata_file" ]; then
            local cache_timestamp=$(jq -r '.cache_timestamp' "$metadata_file" 2>/dev/null || echo "")
            if [ -n "$cache_timestamp" ]; then
                local cache_age=$(($(date +%s) - $(date -d "$cache_timestamp" +%s 2>/dev/null || echo 0)))
                local max_cache_age=$((30 * 60))  # 30 minutes for testing

                if [ $cache_age -lt $max_cache_age ]; then
                    use_cache="true"
                fi
            fi
        fi

        if [ "$use_cache" = "true" ]; then
            # Simulate cache hit
            measure_execution "optimized_govulncheck_cache_hit" "cat $cache_file" "$i"
        else
            # Simulate cache miss - run scan and cache result
            local command="govulncheck -format json ./... | tee $cache_file"
            measure_execution "optimized_govulncheck_cache_miss" "$command" "$i"

            # Create cache metadata
            cat > "$metadata_file" <<EOF
{
  "cache_timestamp": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
  "govulncheck_version": "v1.1.3",
  "go_sum_hash": "$(sha256sum go.sum | cut -d' ' -f1 2>/dev/null || echo 'unknown')"
}
EOF
        fi
    done

    # Cleanup cache files
    rm -f "$cache_file" "$metadata_file"
}

# Test 4: Binary caching simulation
test_binary_caching_overhead() {
    log_benchmark "INFO" "Testing binary installation overhead"

    local govulncheck_path="/tmp/test-govulncheck"

    for i in $(seq 1 "$ITERATIONS"); do
        # Simulate binary installation
        if [ ! -f "$govulncheck_path" ]; then
            # Copy existing binary to simulate "installation"
            local start_time=$(date +%s)
            cp "$(which govulncheck)" "$govulncheck_path" 2>/dev/null || {
                # If copy fails, simulate installation time
                sleep 0.5
                touch "$govulncheck_path"
            }
            local end_time=$(date +%s)
            local duration_ms=$(((end_time - start_time) * 1000))

            local result="{
                \"test_name\": \"binary_installation_simulation\",
                \"iteration\": $i,
                \"duration_ms\": $duration_ms,
                \"exit_code\": 0,
                \"timestamp\": \"$(date -u '+%Y-%m-%dT%H:%M:%SZ')\",
                \"command\": \"simulate binary installation\"
            }"

            local temp_file=$(mktemp)
            jq ".test_scenarios += [$result]" "$OUTPUT_FILE" > "$temp_file"
            mv "$temp_file" "$OUTPUT_FILE"
        fi

        # Use cached binary
        measure_execution "binary_cache_hit" "echo 'Using cached binary: $govulncheck_path'" "$i"
    done

    rm -f "$govulncheck_path"
}

# Generate summary statistics
generate_summary() {
    log_benchmark "INFO" "Generating performance summary"

    local temp_file=$(mktemp)

    # Calculate statistics for each test type
    jq '
    .test_scenarios |
    group_by(.test_name) |
    map({
        test_name: .[0].test_name,
        iterations: length,
        min_duration_ms: map(.duration_ms) | min,
        max_duration_ms: map(.duration_ms) | max,
        avg_duration_ms: (map(.duration_ms) | add / length | round),
        median_duration_ms: (map(.duration_ms) | sort | .[length/2] | round),
        total_duration_ms: (map(.duration_ms) | add),
        success_rate: (map(select(.exit_code == 0)) | length / length * 100 | round)
    }) as $stats |
    .summary = {
        test_statistics: $stats,
        performance_comparison: {
            baseline_test: "direct_govulncheck",
            comparisons: []
        },
        recommendations: []
    }
    ' "$OUTPUT_FILE" > "$temp_file"

    mv "$temp_file" "$OUTPUT_FILE"

    # Add performance comparisons
    local direct_avg=$(jq -r '.summary.test_statistics[] | select(.test_name == "direct_govulncheck") | .avg_duration_ms' "$OUTPUT_FILE")

    if [ "$direct_avg" != "null" ] && [ -n "$direct_avg" ]; then
        for test_name in "ci_style_govulncheck" "optimized_govulncheck_cache_hit" "optimized_govulncheck_cache_miss"; do
            local test_avg=$(jq -r ".summary.test_statistics[] | select(.test_name == \"$test_name\") | .avg_duration_ms" "$OUTPUT_FILE")

            if [ "$test_avg" != "null" ] && [ -n "$test_avg" ]; then
                local improvement_pct=$(echo "scale=1; ($direct_avg - $test_avg) / $direct_avg * 100" | bc -l 2>/dev/null || echo "0")

                local comparison="{
                    \"test_name\": \"$test_name\",
                    \"avg_duration_ms\": $test_avg,
                    \"vs_baseline_ms\": $(($test_avg - $direct_avg)),
                    \"improvement_percent\": $improvement_pct
                }"

                local temp_file=$(mktemp)
                jq ".summary.performance_comparison.comparisons += [$comparison]" "$OUTPUT_FILE" > "$temp_file"
                mv "$temp_file" "$OUTPUT_FILE"
            fi
        done
    fi

    # Add recommendations based on results
    local recommendations='[
        "Enable Go module caching in GitHub Actions (actions/setup-go with cache: true)",
        "Cache govulncheck binary to avoid repeated installations",
        "Implement result caching for scenarios where dependencies haven'\''t changed",
        "Consider 6-hour TTL for vulnerability scan result cache",
        "Cache system tools (yq, gh) to reduce setup overhead"
    ]'

    local temp_file=$(mktemp)
    jq ".summary.recommendations = $recommendations" "$OUTPUT_FILE" > "$temp_file"
    mv "$temp_file" "$OUTPUT_FILE"
}

# Display results summary
display_results() {
    echo
    echo "========================================"
    echo "Vulnerability Scanning Performance Benchmark Results"
    echo "========================================"
    echo

    # Display test statistics
    echo "Test Performance Summary:"
    jq -r '.summary.test_statistics[] |
        "  \(.test_name):" +
        "\n    Iterations: \(.iterations)" +
        "\n    Average: \(.avg_duration_ms)ms" +
        "\n    Min: \(.min_duration_ms)ms" +
        "\n    Max: \(.max_duration_ms)ms" +
        "\n    Success Rate: \(.success_rate)%" +
        "\n"' "$OUTPUT_FILE"

    # Display performance comparisons
    echo "Performance Improvements vs Baseline:"
    jq -r '.summary.performance_comparison.comparisons[]? |
        "  \(.test_name): \(.improvement_percent)% improvement (\(.vs_baseline_ms)ms difference)"' "$OUTPUT_FILE"

    echo
    echo "Recommendations:"
    jq -r '.summary.recommendations[]? | "  • \(.)"' "$OUTPUT_FILE"

    echo
    echo "Full benchmark results saved to: $OUTPUT_FILE"
}

# Main execution
main() {
    echo "Starting vulnerability scanning performance benchmark..."
    echo "Iterations: $ITERATIONS"
    echo "Output file: $OUTPUT_FILE"
    echo

    check_prerequisites
    init_benchmark

    # Run all test scenarios
    test_direct_govulncheck
    test_ci_style_govulncheck
    test_optimized_govulncheck
    test_binary_caching_overhead

    generate_summary
    display_results

    log_benchmark "INFO" "Benchmark completed successfully"
}

# Run main function
main "$@"
