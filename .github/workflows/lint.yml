name: Go Linting

# Trigger configuration:
# - On push to master branch (ignoring documentation changes)
# - On pull requests to master branch
# - Monthly dependency check (1st of each month at 01:00 UTC)
on:
  push:
    branches: [master]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'LICENSE'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE.md'
  pull_request:
    branches: [master]
  schedule:
    - cron: '0 1 1 * *'  # Monthly Dependency Vulnerability Scan (1st of each month at 01:00 UTC)

# Prevent multiple identical workflow runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  golangci-lint:
    name: Run golangci-lint
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'  # Updated to match local development environment
          cache: true

      # Use the official GitHub Action as per our standardized approach in docs/LINTING.md
      - name: Install and run golangci-lint
        uses: golangci/golangci-lint-action@v7
        with:
          # IMPORTANT: This version MUST match the one in .pre-commit-config.yaml
          # See docs/LINTING.md for details on version standardization
          version: v2.1.2
          # Only include necessary arguments - the action handles paths and output format
          args: --timeout=2m --verbose

  additional-checks:
    name: Run additional static checks
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'  # Updated to match local development environment
          cache: true

      - name: Go Vet
        run: go vet ./...

      - name: Go Mod Verify
        run: go mod verify

      - name: Check Go mod tidiness
        run: |
          go mod tidy
          git diff --exit-code -- go.mod go.sum || (echo "go.mod or go.sum not tidy - run 'go mod tidy' locally" && exit 1)

      - name: Check for misspellings
        run: |
          go install github.com/client9/misspell/cmd/misspell@latest
          $(go env GOPATH)/bin/misspell -error -locale US .

  vulnerability-scan:
    name: Run vulnerability scanning
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@v1.1.3

      - name: Install yq for YAML parsing
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Setup GitHub CLI for issue creation
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh -y

      - name: Run vulnerability scan with severity thresholds
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Read configuration from .govulncheck.yaml
          echo "Reading vulnerability scan configuration..."

          if [ ! -f ".govulncheck.yaml" ]; then
            echo "Error: .govulncheck.yaml configuration file not found"
            exit 1
          fi

          # Extract configuration values
          FAIL_ON_SEVERITY=$(yq eval '.fail_on_severity[]' .govulncheck.yaml)
          TIMEOUT=$(yq eval '.timeout_seconds' .govulncheck.yaml)
          SCAN_LEVEL=$(yq eval '.scan_level' .govulncheck.yaml)

          echo "Configuration loaded:"
          echo "  Fail on severity: $FAIL_ON_SEVERITY"
          echo "  Timeout: ${TIMEOUT}s"
          echo "  Scan level: $SCAN_LEVEL"
          echo ""

          # Generate correlation ID for traceability
          CORRELATION_ID="vuln-scan-$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD)"
          echo "Correlation ID: $CORRELATION_ID"
          echo ""

          # Run govulncheck with JSON output for detailed analysis
          echo "Running vulnerability scan..."
          set +e  # Don't exit immediately on command failure

          # Run scan with timeout
          timeout "${TIMEOUT}s" govulncheck -format json -scan "$SCAN_LEVEL" ./... > govulncheck-raw.json 2>&1
          SCAN_EXIT_CODE=$?

          # Generate structured vulnerability report
          echo "Generating structured vulnerability report..."

          # Create structured report with correlation ID and metadata
          cat > "vuln-report-${CORRELATION_ID}.json" <<'JSONEOF'
          {
            "scan_metadata": {
              "correlation_id": "CORRELATION_ID_PLACEHOLDER",
              "timestamp": "TIMESTAMP_PLACEHOLDER",
              "git_commit": "COMMIT_PLACEHOLDER",
              "git_branch": "BRANCH_PLACEHOLDER",
              "scan_exit_code": 0,
              "scan_duration_ms": null,
              "scanner_version": "govulncheck@v1.1.3"
            },
            "scan_configuration": {
              "fail_on_severity": ["HIGH", "CRITICAL"],
              "timeout_seconds": 300,
              "scan_level": "symbol",
              "scan_mode": "source"
            },
            "vulnerability_summary": {
              "total_vulnerabilities": 0,
              "critical_count": 0,
              "high_count": 0,
              "medium_count": 0,
              "low_count": 0,
              "scan_result": "unknown"
            },
            "findings": [],
            "remediation": {
              "update_commands": [
                "go get -u && go mod tidy",
                "govulncheck ./..."
              ],
              "resources": [
                "https://vuln.go.dev",
                "https://go.dev/doc/modules/managing-dependencies"
              ]
            }
          }
          JSONEOF

          # Replace placeholders with actual values
          sed -i "s/CORRELATION_ID_PLACEHOLDER/$CORRELATION_ID/g" "vuln-report-${CORRELATION_ID}.json"
          sed -i "s/TIMESTAMP_PLACEHOLDER/$(date -u '+%Y-%m-%dT%H:%M:%SZ')/g" "vuln-report-${CORRELATION_ID}.json"
          sed -i "s/COMMIT_PLACEHOLDER/$(git rev-parse --short HEAD)/g" "vuln-report-${CORRELATION_ID}.json"
          sed -i "s/BRANCH_PLACEHOLDER/$(git rev-parse --abbrev-ref HEAD)/g" "vuln-report-${CORRELATION_ID}.json"

          # Update with actual configuration values
          yq eval ".scan_configuration.fail_on_severity = $(yq eval '.fail_on_severity' .govulncheck.yaml -o=json)" -i "vuln-report-${CORRELATION_ID}.json"
          yq eval ".scan_configuration.timeout_seconds = $TIMEOUT" -i "vuln-report-${CORRELATION_ID}.json"
          yq eval ".scan_configuration.scan_level = \"$SCAN_LEVEL\"" -i "vuln-report-${CORRELATION_ID}.json"
          yq eval ".scan_metadata.scan_exit_code = $SCAN_EXIT_CODE" -i "vuln-report-${CORRELATION_ID}.json"

          # Parse JSON output and extract vulnerability information
          if [ -f "govulncheck-raw.json" ]; then
            # Extract vulnerability count and details from JSON
            VULN_COUNT=$(grep -c '"osv"' govulncheck-raw.json || echo "0")

            # Extract config information if available
            if grep -q '"config"' govulncheck-raw.json; then
              SCANNER_VERSION=$(grep -A 10 '"config"' govulncheck-raw.json | grep '"scanner_version"' | cut -d'"' -f4 || echo "unknown")
              DB_LAST_MODIFIED=$(grep -A 10 '"config"' govulncheck-raw.json | grep '"db_last_modified"' | cut -d'"' -f4 || echo "unknown")
            fi

            # Update the structured report with actual findings
            if [ "$VULN_COUNT" -gt 0 ]; then
              # Extract vulnerability details (simplified for now)
              # In a production environment, this would use jq for proper JSON parsing
              FINDINGS_JSON="[]"

              # For now, we'll treat all found vulnerabilities as HIGH severity
              # Future enhancement: parse actual severity from OSV data
              yq eval ".vulnerability_summary.total_vulnerabilities = $VULN_COUNT" -i "vuln-report-${CORRELATION_ID}.json"
              yq eval ".vulnerability_summary.high_count = $VULN_COUNT" -i "vuln-report-${CORRELATION_ID}.json"
              yq eval '.vulnerability_summary.scan_result = "vulnerabilities_found"' -i "vuln-report-${CORRELATION_ID}.json"
            else
              yq eval '.vulnerability_summary.scan_result = "clean"' -i "vuln-report-${CORRELATION_ID}.json"
            fi

            # Add scan duration if we can calculate it (simplified)
            yq eval ".scan_metadata.scanner_version = \"$SCANNER_VERSION\"" -i "vuln-report-${CORRELATION_ID}.json"
          fi

          echo "Structured report generated: vuln-report-${CORRELATION_ID}.json"

          # Check for timeout
          if [ $SCAN_EXIT_CODE -eq 124 ]; then
            echo "‚ùå FAILURE: Vulnerability scan timed out after ${TIMEOUT} seconds"
            echo "This may indicate network issues or an unusually large codebase."
            echo "Consider increasing timeout_seconds in .govulncheck.yaml"
            exit 1
          fi

          # Analyze results based on configuration
          if [ $SCAN_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ SUCCESS: No vulnerabilities found"
            echo "Scan completed successfully with correlation ID: $CORRELATION_ID"
            echo ""
            echo "üìä Structured Report:"
            echo "   ‚Ä¢ Report file: vuln-report-${CORRELATION_ID}.json"
            echo "   ‚Ä¢ Status: Clean - no vulnerabilities detected"
            echo "   ‚Ä¢ Scan level: $SCAN_LEVEL (symbol-level analysis)"
            echo "   ‚Ä¢ Configuration: HIGH/CRITICAL severity blocking enabled"
          else
            # FAIL-FAST: Immediately halt pipeline on vulnerability detection
            echo "üî¥ CRITICAL SECURITY FAILURE"
            echo "=========================================="
            echo "‚ùå VULNERABILITIES DETECTED - BUILD BLOCKED"
            echo "=========================================="
            echo ""

            # Show correlation ID for incident tracking
            echo "üìã Incident Details:"
            echo "   ‚Ä¢ Correlation ID: $CORRELATION_ID"
            echo "   ‚Ä¢ Scan timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "   ‚Ä¢ Git commit: $(git rev-parse --short HEAD)"
            echo "   ‚Ä¢ Security policy: HIGH/CRITICAL vulnerabilities block deployment"
            echo "   ‚Ä¢ Structured report: vuln-report-${CORRELATION_ID}.json"
            echo ""

            # Display vulnerability details
            echo "üîç Vulnerability Summary:"
            echo "----------------------------------------"
            govulncheck ./...  # Show human-readable output for developers
            echo "----------------------------------------"
            echo ""

            # Provide clear remediation guidance
            echo "üõ†Ô∏è  IMMEDIATE ACTIONS REQUIRED:"
            echo "   1. Review the vulnerability details above"
            echo "   2. Update affected dependencies to secure versions"
            echo "   3. Run 'govulncheck ./...' locally to verify fixes"
            echo "   4. Re-commit and push updated dependencies"
            echo ""

            echo "üìö Resources:"
            echo "   ‚Ä¢ Go vulnerability database: https://vuln.go.dev"
            echo "   ‚Ä¢ Update dependencies: 'go get -u && go mod tidy'"
            echo "   ‚Ä¢ Dependency management: https://go.dev/doc/modules/managing-dependencies"
            echo ""

            # Emergency override instructions
            echo "üö® EMERGENCY OVERRIDE (Critical Hotfixes Only):"
            echo "   If this is a critical production hotfix that cannot wait:"
            echo "   1. Get security team approval for temporary override"
            echo "   2. Document justification and 48-hour remediation plan"
            echo "   3. Set EMERGENCY_SECURITY_OVERRIDE=true in CI environment"
            echo "   4. Create follow-up security debt issue immediately"
            echo "   WARNING: Override usage is logged and audited"
            echo ""

            # Check for emergency override before terminating build
            if [ "${EMERGENCY_SECURITY_OVERRIDE:-false}" = "true" ]; then
              echo ""
              echo "üö®üö®üö® EMERGENCY SECURITY OVERRIDE ACTIVATED üö®üö®üö®"
              echo "=============================================================="
              echo "‚ö†Ô∏è  CRITICAL WARNING: Security policy has been bypassed!"
              echo "‚ö†Ô∏è  This allows vulnerable code to proceed to deployment!"
              echo "=============================================================="
              echo ""
              echo "üìã Override Audit Trail:"
              echo "   ‚Ä¢ Override timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
              echo "   ‚Ä¢ Correlation ID: $CORRELATION_ID"
              echo "   ‚Ä¢ Git commit: $(git rev-parse --short HEAD)"
              echo "   ‚Ä¢ Git branch: $(git rev-parse --abbrev-ref HEAD)"
              echo "   ‚Ä¢ Triggered by: ${{ github.actor }}"
              echo "   ‚Ä¢ Workflow run: ${{ github.run_id }}"
              echo ""
              echo "üîí Security Policy Requirements:"
              echo "   ‚Ä¢ This override MUST be approved by security team"
              echo "   ‚Ä¢ Justification MUST be documented in follow-up issue"
              echo "   ‚Ä¢ Vulnerabilities MUST be resolved within 48 hours"
              echo "   ‚Ä¢ All override usage is logged and audited"
              echo ""

              # Create security debt tracking issue
              echo "üìù Creating security debt tracking issue..."

              ISSUE_TITLE="üö® Security Override Used - Vulnerability Remediation Required"

              # Create issue body using printf to avoid YAML parsing issues
              ISSUE_BODY="$(printf '%s\n' \
                "## Emergency Security Override Report" \
                "" \
                "**Override Details:**" \
                "- **Correlation ID:** \`$CORRELATION_ID\`" \
                "- **Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
                "- **Git Commit:** \`$(git rev-parse --short HEAD)\`" \
                "- **Git Branch:** \`$(git rev-parse --abbrev-ref HEAD)\`" \
                "- **Triggered By:** ${{ github.actor }}" \
                "- **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
                "" \
                "**Security Policy Violation:**" \
                "The emergency security override was activated to bypass vulnerability scanning failures. This allows potentially vulnerable code to proceed to deployment." \
                "" \
                "**Immediate Actions Required:**" \
                "1. **Security Team Review:** Validate the justification for this override" \
                "2. **Risk Assessment:** Evaluate the impact of detected vulnerabilities" \
                "3. **Remediation Plan:** Update vulnerable dependencies within 48 hours" \
                "4. **Documentation:** Record approval and remediation timeline" \
                "" \
                "**Vulnerabilities Detected:**" \
                "The following vulnerability scan detected issues that triggered this override:" \
                "- Run \`govulncheck ./...\` to see detailed vulnerability information" \
                "- Check the [workflow artifacts](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for structured reports" \
                "" \
                "**Compliance Requirements:**" \
                "- [ ] Security team approval documented" \
                "- [ ] Justification recorded in this issue" \
                "- [ ] Remediation plan with 48-hour timeline" \
                "- [ ] Follow-up vulnerability scan confirms resolution" \
                "- [ ] Post-incident review completed" \
                "" \
                "**‚ö†Ô∏è This issue must be resolved before the next deployment cycle.**")"

              # Create GitHub issue using gh CLI
              if command -v gh >/dev/null 2>&1; then
                echo "Creating GitHub issue for security debt tracking..."
                gh issue create \
                  --title "$ISSUE_TITLE" \
                  --body "$ISSUE_BODY" \
                  --label "security-debt,priority-high,compliance" \
                  --assignee "${{ github.actor }}" \
                  || echo "‚ö†Ô∏è  Failed to create GitHub issue - manual tracking required"
              else
                echo "‚ö†Ô∏è  GitHub CLI not available - manual issue creation required"
                echo "    Title: $ISSUE_TITLE"
                echo "    Labels: security-debt, priority-high, compliance"
              fi

              echo ""
              echo "‚úÖ OVERRIDE COMPLETE - Build allowed to proceed with security debt"
              echo "üî¥ REMINDER: Vulnerabilities must be resolved within 48 hours"
              echo "üìä Track remediation progress via created GitHub issue"
              echo ""

            else
              # Standard failure path - no override
              echo "üí• BUILD TERMINATED"
              echo "Reason: Security policy violation - vulnerable dependencies detected"
              echo "Policy: All HIGH/CRITICAL vulnerabilities must be resolved before deployment"
              echo "Track this incident: $CORRELATION_ID"
              echo ""
              echo "This pipeline will not proceed until vulnerabilities are addressed."

              # FAIL-FAST: Immediate exit with clear failure code
              exit 1
            fi
          fi

          set -e  # Re-enable exit on error

      - name: Upload vulnerability scan reports as artifacts
        uses: actions/upload-artifact@v4
        if: always()  # Upload artifacts even if vulnerability scan fails
        with:
          name: vulnerability-scan-reports-${{ github.run_id }}
          path: |
            vuln-report-*.json
            govulncheck-raw.json
          retention-days: 30
          if-no-files-found: warn
