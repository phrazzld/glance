name: Vulnerability Scanning (Optimized)

# Prototype workflow for testing optimized vulnerability scanning with enhanced caching
# This workflow implements multiple caching strategies to improve performance

on:
  push:
    branches: [master]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'LICENSE'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE.md'
  pull_request:
    branches: [master]
  workflow_dispatch:  # Allow manual triggering for testing

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  vulnerability-scan-optimized:
    name: Optimized vulnerability scanning with caching
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Go with enhanced caching
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          # Use specific cache-dependency-path for better cache precision
          cache-dependency-path: |
            go.sum
            config/go.sum
            llm/go.sum
            ui/go.sum
            filesystem/go.sum
            errors/go.sum

      # Cache govulncheck binary to avoid reinstalling it every run
      - name: Cache govulncheck binary
        id: cache-govulncheck
        uses: actions/cache@v4
        with:
          path: ~/go/bin/govulncheck
          key: govulncheck-${{ runner.os }}-v1.1.3
          restore-keys: |
            govulncheck-${{ runner.os }}-

      - name: Install govulncheck (if not cached)
        if: steps.cache-govulncheck.outputs.cache-hit != 'true'
        run: |
          echo "Installing govulncheck v1.1.3..."
          go install golang.org/x/vuln/cmd/govulncheck@v1.1.3
          echo "govulncheck installed to $(which govulncheck)"

      # Cache system tools (yq, gh) to avoid repeated downloads
      - name: Cache system tools
        id: cache-tools
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/bin/yq
            ~/.cache/gh
          key: tools-${{ runner.os }}-yq-gh-${{ hashFiles('.github/workflows/vulnerability-scan-optimized.yml') }}
          restore-keys: |
            tools-${{ runner.os }}-yq-gh-

      - name: Install yq (if not cached)
        if: steps.cache-tools.outputs.cache-hit != 'true'
        run: |
          echo "Installing yq..."
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Install GitHub CLI (if not cached)
        if: steps.cache-tools.outputs.cache-hit != 'true'
        run: |
          echo "Installing GitHub CLI..."
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh -y

      # Cache vulnerability scan results based on go.sum and govulncheck version
      # This implements a form of result caching since govulncheck doesn't have built-in caching
      - name: Cache vulnerability scan results
        id: cache-vuln-results
        uses: actions/cache@v4
        with:
          path: |
            vuln-scan-cache.json
            vuln-scan-metadata.json
          key: vuln-scan-${{ runner.os }}-${{ hashFiles('go.sum', 'config/go.sum', 'llm/go.sum', 'ui/go.sum', 'filesystem/go.sum', 'errors/go.sum') }}-govulncheck-v1.1.3-${{ github.run_id }}
          restore-keys: |
            vuln-scan-${{ runner.os }}-${{ hashFiles('go.sum', 'config/go.sum', 'llm/go.sum', 'ui/go.sum', 'filesystem/go.sum', 'errors/go.sum') }}-govulncheck-v1.1.3-
            vuln-scan-${{ runner.os }}-${{ hashFiles('go.sum', 'config/go.sum', 'llm/go.sum', 'ui/go.sum', 'filesystem/go.sum', 'errors/go.sum') }}-

      - name: Check cached vulnerability results validity
        id: check-cache-validity
        run: |
          # Check if cached results exist and are still valid
          if [ -f "vuln-scan-cache.json" ] && [ -f "vuln-scan-metadata.json" ]; then
            # Extract cache timestamp and database last modified from metadata
            CACHE_TIMESTAMP=$(jq -r '.cache_timestamp' vuln-scan-metadata.json 2>/dev/null || echo "")
            CACHED_DB_MODIFIED=$(jq -r '.db_last_modified' vuln-scan-metadata.json 2>/dev/null || echo "")

            # Check if cache is less than 6 hours old (vulnerability DB doesn't update that frequently)
            if [ -n "$CACHE_TIMESTAMP" ]; then
              CACHE_AGE=$(($(date +%s) - $(date -d "$CACHE_TIMESTAMP" +%s 2>/dev/null || echo 0)))
              MAX_CACHE_AGE=$((6 * 3600))  # 6 hours in seconds

              if [ $CACHE_AGE -lt $MAX_CACHE_AGE ]; then
                echo "Cache is valid (age: ${CACHE_AGE}s < ${MAX_CACHE_AGE}s)"
                echo "use_cache=true" >> $GITHUB_OUTPUT
              else
                echo "Cache is too old (age: ${CACHE_AGE}s >= ${MAX_CACHE_AGE}s)"
                echo "use_cache=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "Cache timestamp not found, invalidating cache"
              echo "use_cache=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "No cached results found"
            echo "use_cache=false" >> $GITHUB_OUTPUT
          fi

      - name: Run optimized vulnerability scan
        env:
          GH_TOKEN: ${{ github.token }}
          USE_CACHE: ${{ steps.check-cache-validity.outputs.use_cache }}
        run: |
          # Generate correlation ID for this scan
          CORRELATION_ID="vuln-scan-optimized-$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD)"
          SCAN_START_TIME=$(date +%s%3N)

          echo "Starting optimized vulnerability scan with correlation ID: $CORRELATION_ID"

          # Structured logging function
          log_structured() {
            local level="$1"
            local message="$2"
            local cache_status="${3:-}"
            local scan_duration_ms="${4:-}"

            local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%S.%3NZ')
            local git_commit=$(git rev-parse --short HEAD)

            local log_entry="{"
            log_entry="${log_entry}\"timestamp\": \"$timestamp\","
            log_entry="${log_entry}\"level\": \"$level\","
            log_entry="${log_entry}\"service_name\": \"vulnerability-scanner-optimized\","
            log_entry="${log_entry}\"correlation_id\": \"$CORRELATION_ID\","
            log_entry="${log_entry}\"git_commit\": \"$git_commit\","
            log_entry="${log_entry}\"message\": \"$message\""

            if [ -n "$cache_status" ]; then
              log_entry="${log_entry},\"cache_status\": \"$cache_status\""
            fi

            if [ -n "$scan_duration_ms" ]; then
              log_entry="${log_entry},\"scan_duration_ms\": $scan_duration_ms"
            fi

            log_entry="${log_entry}}"
            echo "$log_entry" >&2
          }

          if [ "$USE_CACHE" = "true" ]; then
            echo "Using cached vulnerability scan results"
            log_structured "INFO" "Using cached vulnerability scan results" "cache_hit"

            # Use cached results
            cp vuln-scan-cache.json govulncheck-raw.json
            SCAN_EXIT_CODE=0
            SCAN_END_TIME=$(date +%s%3N)
            SCAN_DURATION_MS=$((SCAN_END_TIME - SCAN_START_TIME))

            log_structured "INFO" "Vulnerability scan completed using cache" "cache_hit" "$SCAN_DURATION_MS"
          else
            echo "Running fresh vulnerability scan"
            log_structured "INFO" "Running fresh vulnerability scan" "cache_miss"

            # Check configuration file
            if [ ! -f ".govulncheck.yaml" ]; then
              log_structured "ERROR" "Configuration file .govulncheck.yaml not found"
              exit 1
            fi

            # Extract timeout configuration
            TIMEOUT=$(yq eval '.timeout_seconds' .govulncheck.yaml)
            SCAN_LEVEL=$(yq eval '.scan_level' .govulncheck.yaml)

            echo "Running govulncheck with timeout: ${TIMEOUT}s, scan level: $SCAN_LEVEL"

            # Run govulncheck with JSON output
            set +e
            timeout "${TIMEOUT}s" govulncheck -format json -scan "$SCAN_LEVEL" ./... > govulncheck-raw.json 2>&1
            SCAN_EXIT_CODE=$?
            set -e

            SCAN_END_TIME=$(date +%s%3N)
            SCAN_DURATION_MS=$((SCAN_END_TIME - SCAN_START_TIME))

            if [ $SCAN_EXIT_CODE -eq 0 ]; then
              # Cache successful results
              cp govulncheck-raw.json vuln-scan-cache.json

              # Create metadata for cache validation
              cat > vuln-scan-metadata.json <<EOF
          {
            "cache_timestamp": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
            "correlation_id": "$CORRELATION_ID",
            "govulncheck_version": "v1.1.3",
            "scan_duration_ms": $SCAN_DURATION_MS,
            "go_sum_hash": "$(sha256sum go.sum | cut -d' ' -f1)",
            "db_last_modified": "$(grep -o '"db_last_modified": "[^"]*"' govulncheck-raw.json | cut -d'"' -f4 || echo 'unknown')"
          }
          EOF

              log_structured "INFO" "Vulnerability scan completed and results cached" "cache_miss" "$SCAN_DURATION_MS"
            else
              log_structured "ERROR" "Vulnerability scan failed" "cache_miss" "$SCAN_DURATION_MS"
            fi
          fi

          # Process results (same as original workflow)
          echo "Processing scan results..."

          # Create structured report
          cat > "vuln-report-${CORRELATION_ID}.json" <<'JSONEOF'
          {
            "scan_metadata": {
              "correlation_id": "CORRELATION_ID_PLACEHOLDER",
              "timestamp": "TIMESTAMP_PLACEHOLDER",
              "git_commit": "COMMIT_PLACEHOLDER",
              "scan_exit_code": 0,
              "scan_duration_ms": 0,
              "scanner_version": "govulncheck@v1.1.3",
              "cache_status": "CACHE_STATUS_PLACEHOLDER"
            },
            "scan_configuration": {
              "fail_on_severity": ["HIGH", "CRITICAL"],
              "timeout_seconds": 300,
              "scan_level": "symbol"
            },
            "vulnerability_summary": {
              "total_vulnerabilities": 0,
              "critical_count": 0,
              "high_count": 0,
              "medium_count": 0,
              "low_count": 0,
              "scan_result": "unknown"
            },
            "findings": []
          }
          JSONEOF

          # Replace placeholders
          sed -i "s/CORRELATION_ID_PLACEHOLDER/$CORRELATION_ID/g" "vuln-report-${CORRELATION_ID}.json"
          sed -i "s/TIMESTAMP_PLACEHOLDER/$(date -u '+%Y-%m-%dT%H:%M:%SZ')/g" "vuln-report-${CORRELATION_ID}.json"
          sed -i "s/COMMIT_PLACEHOLDER/$(git rev-parse --short HEAD)/g" "vuln-report-${CORRELATION_ID}.json"
          sed -i "s/CACHE_STATUS_PLACEHOLDER/$USE_CACHE/g" "vuln-report-${CORRELATION_ID}.json"
          yq eval ".scan_metadata.scan_exit_code = $SCAN_EXIT_CODE" -i "vuln-report-${CORRELATION_ID}.json"
          yq eval ".scan_metadata.scan_duration_ms = $SCAN_DURATION_MS" -i "vuln-report-${CORRELATION_ID}.json"

          # Parse results and handle based on exit code
          if [ $SCAN_EXIT_CODE -eq 0 ]; then
            echo "âœ… SUCCESS: No vulnerabilities found"
            echo "Scan completed in ${SCAN_DURATION_MS}ms with caching optimizations"
            yq eval '.vulnerability_summary.scan_result = "clean"' -i "vuln-report-${CORRELATION_ID}.json"
          else
            echo "ðŸ”´ VULNERABILITIES DETECTED"
            echo "Scan failed in ${SCAN_DURATION_MS}ms"
            yq eval '.vulnerability_summary.scan_result = "vulnerabilities_found"' -i "vuln-report-${CORRELATION_ID}.json"

            # For this prototype, we'll just log the failure without blocking
            echo "âš ï¸  In prototype mode - would normally block pipeline here"
          fi

      - name: Generate performance comparison summary
        if: always()
        run: |
          echo "## ðŸš€ Optimized Vulnerability Scan Performance" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Find the most recent report
          REPORT_FILE=$(ls -t vuln-report-*.json 2>/dev/null | head -1 || echo "")

          if [ -n "$REPORT_FILE" ] && [ -f "$REPORT_FILE" ]; then
            CORRELATION_ID=$(yq eval '.scan_metadata.correlation_id' "$REPORT_FILE" 2>/dev/null || echo "unknown")
            SCAN_DURATION=$(yq eval '.scan_metadata.scan_duration_ms' "$REPORT_FILE" 2>/dev/null || echo "0")
            CACHE_STATUS=$(yq eval '.scan_metadata.cache_status' "$REPORT_FILE" 2>/dev/null || echo "unknown")
            SCAN_RESULT=$(yq eval '.vulnerability_summary.scan_result' "$REPORT_FILE" 2>/dev/null || echo "unknown")

            echo "**Performance Metrics:**" >> $GITHUB_STEP_SUMMARY
            echo "- **Correlation ID:** \`$CORRELATION_ID\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Scan Duration:** ${SCAN_DURATION}ms" >> $GITHUB_STEP_SUMMARY
            echo "- **Cache Status:** $CACHE_STATUS" >> $GITHUB_STEP_SUMMARY
            echo "- **Result:** $SCAN_RESULT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Cache hit information
            if [ "$CACHE_STATUS" = "true" ]; then
              echo "### ðŸŽ¯ Cache Hit!" >> $GITHUB_STEP_SUMMARY
              echo "Vulnerability scan results were served from cache, significantly improving performance." >> $GITHUB_STEP_SUMMARY
            else
              echo "### ðŸ”„ Cache Miss" >> $GITHUB_STEP_SUMMARY
              echo "Fresh vulnerability scan performed. Results cached for future runs." >> $GITHUB_STEP_SUMMARY
            fi

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Caching Optimizations Applied:**" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Go modules and build cache (via actions/setup-go)" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… govulncheck binary caching" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… System tools caching (yq, gh)" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Vulnerability scan result caching (6-hour TTL)" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Could not generate performance metrics - scan report not found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload optimized scan artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: optimized-vulnerability-scan-${{ github.run_id }}
          path: |
            vuln-report-*.json
            govulncheck-raw.json
            vuln-scan-metadata.json
          retention-days: 30
          if-no-files-found: warn
