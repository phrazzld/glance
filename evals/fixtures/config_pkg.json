{
  "directory": "glance/config",
  "files": {
    "config.go": "// Package config provides configuration management for the glance application.\npackage config\n\nimport \"glance/llm\"\n\n// Config holds the application configuration parameters.\n// This structure centralizes all application settings, making them easier to\n// manage, test, and extend in the future.\ntype Config struct {\n\t// APIKey is the Gemini API key used for generating content\n\tAPIKey string\n\n\t// TargetDir is the directory to scan and generate glance.md files for\n\tTargetDir string\n\n\t// Force indicates whether to regenerate existing glance.md files\n\tForce bool\n\n\t// PromptTemplate contains the template text used for generating prompts\n\tPromptTemplate string\n\n\t// MaxRetries defines how many times to retry API calls before giving up\n\tMaxRetries int\n\n\t// MaxFileBytes is the maximum file size in bytes to process (larger files are truncated)\n\tMaxFileBytes int64\n}\n\n// Default constants used in configuration\nconst (\n\t// DefaultMaxRetries is the default number of API retry attempts\n\tDefaultMaxRetries = 3\n\n\t// DefaultMaxFileBytes is the default maximum file size (5MB)\n\tDefaultMaxFileBytes = 5 * 1024 * 1024\n)\n\n// NewDefaultConfig creates a new Config with default values.\n// This provides a starting point for configuration that can be\n// customized using the With* methods.\nfunc NewDefaultConfig() *Config {\n\treturn &Config{\n\t\tAPIKey:         \"\",\n\t\tTargetDir:      \"\",\n\t\tForce:          false,\n\t\tPromptTemplate: llm.DefaultTemplate(),\n\t\tMaxRetries:     DefaultMaxRetries,\n\t\tMaxFileBytes:   DefaultMaxFileBytes,\n\t}\n}\n\n// WithAPIKey returns a new Config with the specified API key.\nfunc (c *Config) WithAPIKey(apiKey string) *Config {\n\t// Create a copy of the config to ensure immutability\n\tnewConfig := *c\n\tnewConfig.APIKey = apiKey // pragma: allowlist secret\n\treturn &newConfig\n}\n\n// WithTargetDir returns a new Config with the specified target directory.\nfunc (c *Config) WithTargetDir(targetDir string) *Config {\n\tnewConfig := *c\n\tnewConfig.TargetDir = targetDir\n\treturn &newConfig\n}\n\n// WithForce returns a new Config with the specified force flag value.\nfunc (c *Config) WithForce(force bool) *Config {\n\tnewConfig := *c\n\tnewConfig.Force = force\n\treturn &newConfig\n}\n\n// WithPromptTemplate returns a new Config with the specified prompt template.\nfunc (c *Config) WithPromptTemplate(template string) *Config {\n\tnewConfig := *c\n\tnewConfig.PromptTemplate = template\n\treturn &newConfig\n}\n\n// WithMaxRetries returns a new Config with the specified max retries value.\nfunc (c *Config) WithMaxRetries(maxRetries int) *Config {\n\tnewConfig := *c\n\tnewConfig.MaxRetries = maxRetries\n\treturn &newConfig\n}\n\n// WithMaxFileBytes returns a new Config with the specified max file bytes value.\nfunc (c *Config) WithMaxFileBytes(maxFileBytes int64) *Config {\n\tnewConfig := *c\n\tnewConfig.MaxFileBytes = maxFileBytes\n\treturn &newConfig\n}\n",
    "loadconfig.go": "package config\n\nimport (\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/joho/godotenv\"\n\t\"github.com/sirupsen/logrus\"\n\n\t\"glance/llm\"\n)\n\n// LoadPromptTemplateFunc defines a function type for loading prompt templates\n// This allows us to replace it in tests\ntype LoadPromptTemplateFunc func(path string) (string, error)\n\n// loadPromptTemplate is the function to use for loading prompt templates\nvar loadPromptTemplate LoadPromptTemplateFunc = LoadPromptTemplate\n\n// directoryChecker defines an interface for checking directory existence\n// This allows for easier testing by substituting a mock implementation\ntype directoryChecker interface {\n\t// CheckDirectory verifies the path exists and is a directory\n\t// Returns the validated path (can be relative or absolute) and any error\n\tCheckDirectory(path string) (string, error)\n}\n\n// defaultChecker implements the directoryChecker interface using the real filesystem\ntype defaultChecker struct{}\n\n// CheckDirectory verifies the path exists and is a directory\n// It accepts and preserves relative paths rather than forcing absolute conversion\nfunc (d *defaultChecker) CheckDirectory(path string) (string, error) {\n\t// Clean the path to normalize it, but preserve its relative/absolute state\n\tcleanPath := filepath.Clean(path)\n\n\tstat, err := os.Stat(cleanPath)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"cannot access directory %q: %w\", cleanPath, err)\n\t}\n\tif !stat.IsDir() {\n\t\treturn \"\", fmt.Errorf(\"path %q is a file, not a directory\", cleanPath)\n\t}\n\treturn cleanPath, nil\n}\n\n// Global variable to allow tests to override the directory checker\nvar dirChecker directoryChecker = &defaultChecker{}\n\n// LoadConfig parses command-line flags, loads environment variables,\n// and initializes the application configuration.\n//\n// It handles:\n// - Command-line flag parsing\n// - Loading environment variables from .env file\n// - Reading the prompt template\n// - Validating required settings\n//\n// The args parameter should contain the full command-line arguments\n// (including the program name in args[0]).\nfunc LoadConfig(args []string) (*Config, error) {\n\t// Start with a default configuration\n\tcfg := NewDefaultConfig()\n\n\t// Define flags\n\tcmdFlags := flag.NewFlagSet(args[0], flag.ContinueOnError)\n\tvar (\n\t\tforce      bool\n\t\tpromptFile string\n\t)\n\n\tcmdFlags.BoolVar(&force, \"force\", false, \"regenerate glance.md even if it already exists\")\n\tcmdFlags.StringVar(&promptFile, \"prompt-file\", \"\", \"path to custom prompt file (overrides default)\")\n\n\t// Parse flags\n\tif err := cmdFlags.Parse(args[1:]); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse command-line arguments: %w\", err)\n\t}\n\n\t// Validate target directory \u2014 default to current directory when omitted\n\tif cmdFlags.NArg() > 1 {\n\t\treturn nil, errors.New(\"too many arguments: at most one directory may be specified\")\n\t}\n\n\t// Get target directory and validate it\n\ttargetDir := \".\"\n\tif cmdFlags.NArg() == 1 {\n\t\ttargetDir = cmdFlags.Arg(0)\n\t}\n\n\t// Check if directory exists and is actually a directory\n\t// The directoryChecker will clean the path and verify it's a directory\n\tvalidatedDir, err := dirChecker.CheckDirectory(targetDir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Convert to absolute path only if needed for validation boundary\n\t// This is only needed when we need absolute paths for security validation\n\tabsDir := validatedDir\n\tif !filepath.IsAbs(validatedDir) {\n\t\tabsDir, err = filepath.Abs(validatedDir)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid target directory: %w\", err)\n\t\t}\n\t}\n\n\t// Store the validated directory as our trusted root\n\t// This is safe since we've already verified it exists and is a directory\n\n\t// Load .env if present (but don't fail if not found)\n\tif err := godotenv.Load(); err != nil {\n\t\tlogrus.Warn(\"No .env file found or couldn't load it. Using system environment variables instead.\")\n\t}\n\n\t// Get API key from environment\n\tapiKey := os.Getenv(\"GEMINI_API_KEY\")\n\tif apiKey == \"\" {\n\t\treturn nil, errors.New(\"GEMINI_API_KEY is missing: please set this environment variable or add it to your .env file\")\n\t}\n\n\t// Load prompt template using the centralized function\n\tpromptTemplate, err := loadPromptTemplate(promptFile)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load prompt template: %w\", err)\n\t}\n\n\t// If no template was found, use the default from llm package\n\tif promptTemplate == \"\" {\n\t\tpromptTemplate = llm.DefaultTemplate()\n\t}\n\n\t// Apply all configuration settings using the builder pattern\n\tcfg = cfg.\n\t\tWithAPIKey(apiKey).\n\t\tWithTargetDir(absDir).\n\t\tWithForce(force).\n\t\tWithPromptTemplate(promptTemplate)\n\n\treturn cfg, nil\n}\n"
  },
  "subGlances": []
}
